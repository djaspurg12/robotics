\documentclass{article}
\usepackage{listings}
\usepackage{color}
\title{Lab 3: A Machine for Sorting Bricks}
\author{Michael Carpenter \\ Benjamin Liebersohn}
\date{\today}
\begin{document}
\maketitle

\section{Introduction}
For this lab, we were tasked to build a Lego NXT robot capable of sorting colored bricks into one of two categories: light or dark.
Furthermore, it had to be able to do this for a random sequence of bricks of varying color.
The main value of this was to build an autonomous robot through the integration of hardware and software, that could perform a specific task accurately and reliably. 
This had particular value given it reduced the amount of new concepts that had to be wrangled in order to obtain a robot that could actually perform the given task at least passably well.
Only one sensor and one motor was needed to perform the actual sorting and the code involved to control the robot was sort and simple.
That left room for what was probably the most intensive part of the lab: testing the complete robot itself. It took many iterations in order to arrive at our final design.

\section{Hardware}
The Lego sorter is designed to sort the Lego bricks into two categories: light, and dark.
The way our sorter determines this quality is through a reflectively sensor which acts as a proxy to measuring shade.
The idea behind this is that a red LED shines light onto a brick, which then reflects back into a light sensor.
If a brick has a lighter shade, it absorbs less of the light, which can then reflect and be measured.
A higher reading, thus means our brick is likely a lighter shade because it is more reflective of red light.
In order to decide what constitutes light, or dark, our sorter begins by taking samples of light readings and aggregating them to find the ambient light sensor reading.
Once it has done this, it can begin to determine if a brick is light or dark. 
Once that determination has been made, the motor powers a lever which pushes the brick out of the sorter in one of two directions: either the lever is turned counter clockwise to push a light brick to the left (with the light sensor facing the user) or counter clockwise to push the dark brick to the right.
From there, a bumper and deflector guide the brick out of the sorter, into the cups below.
Occasionally, bricks may jam in between a rail and sensor, which is corrected by gears we allow to slip, and thus repeatedly tap the brick with the lever. 
Since the bricks only jam in front of a sensor, the sensor can detect when there is still a brick on the platform, allowing the motor to continue to tap on the jammed brick, which is normally enough to coax the brick out of the corner.

\section{Software}
For the software component, we used a well documented NXT library written in the Haskell programming language, as it was the quickest way to get a program written that worked.
The implementation consists of two function, one to calibrate the robot and the other to actually sort the brick.
When the robot first fires up, it enters into the calibration function which takes a series of readings with the light sensor and then finds the largest reading.
This reading is used as a threshold reading for the sorting function.
The sorting function starts off by taking a reading with the light sensor.
It also takes the threshold value calculated previously during the calibration stage and uses it as a sensitivity baseline on which to decide whether the incoming sensor reading is of a Lego brick or not.
If the reading drops below the calculated threshold, then the reading is interpreted as the fact that there is no brick currently in front of the sensor to be sorted and that the sorter function should simply return.
If the reading is above the threshold, then the reading is compared against a pivot.
Depending on the boolean value of this comparison, the robot will either rotate its single motor clockwise or counter-clockwise.
This caused the robots arm to swipe the Lego left or right.
This function is run in an infinite loop until the program is manually stopped by the user.

\section{Discussion}

\newpage
\appendix
\section{Code}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  deletekeywords={...},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Haskell,
  otherkeywords={*,...},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=2,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
}

\lstinputlisting[language=Haskell]{sorter.hs}
\end{document}
