#define SpeedSlow 50
#define SpeedFast 100

#define FILE_NAME "journey.dat"
#define ENTRIES = 64
#define ENTRY_SIZE = 14
#define FILE_SIZE = (ENTRY_SIZE * ENTRIES)

byte handle = 0;

int rightReading;
int leftReading;
int compassReading;
long rightRotation;
long leftRotation;
long tick = 0;
long previousTurnTime = 0;


struct entry {
  long totalRightRotations;
  long totalLeftRotations;
  long currentTick;
  int heading;
};


task main() { 

  bool keepGoing = true;
  bool shouldStop = false;
  bool shouldTurn = false;
  bool shouldBeCareful = false;
  long timeSinceLastTurn = 0; 


  string rightStr;
  string leftStr;
  string tickStr;
  string compassStr;
  string rightRotationStr;
  string leftRotationStr;
  string timeSinceLastTurnStr;

  string rightMsg;
  string leftMsg;
  string tickMsg;
  string compassMsg;
  string rightRotationMsg;
  string leftRotationMsg;
  string timeSinceLastTurnMsg;

  SetSensorType(IN_1, IN_TYPE_LIGHT_ACTIVE);
  SetSensorMode(IN_1, IN_MODE_RAW);
  
  SetSensorType(IN_2, IN_TYPE_LIGHT_ACTIVE);
  SetSensorMode(IN_2, IN_MODE_RAW);

  SetSensorLowspeed(S3); 


  Wait(600); 


  while (keepGoing == true) {
    entry thisPosition;

    rightReading = SensorRaw(IN_1);
    leftReading = SensorRaw(IN_2);
    tick = CurrentTick();
    rightRotation = MotorRotationCount(OUT_A);
    leftRotation = MotorRotationCount(OUT_B);
    
    thisPosition.currentTick = CurrentTick();
    thisPosition.totalRightRotations = MotorRotationCount(OUT_A);
    thisPosition.totalLeftRotations = MotorRotationCount(OUT_B);
    thisPosition.heading = SensorHTCompass(S3);


    shouldStop = ((leftReading < 500) || (rightReading < 500));
    shouldTurn = (abs(leftReading - rightReading) > 15);
    timeSinceLastTurn = tick - previousTurnTime;
    shouldBeCareful = ((leftReading < 700) && (rightReading < 700));


    rightStr = NumToStr(rightReading);
    leftStr = NumToStr(leftReading);
    tickStr = NumToStr(tick);
    compassStr = NumToStr(compassReading);
    rightRotationStr = NumToStr(rightRotation);
    leftRotationStr = NumToStr(leftRotation);
    timeSinceLastTurnStr = NumToStr(timeSinceLastTurn);


    rightMsg = "R Sensor: " + rightStr;
    leftMsg = "L Sensor: " + leftStr;
    tickMsg = "Time: " + tickStr;
    compassMsg = "Compass: " + compassStr;
    rightRotationMsg = "R Rotations: " + rightRotationStr;
    leftRotationMsg = "L Rotations: " + leftRotationStr;
    timeSinceLastTurnMsg = "Last Turn: " + timeSinceLastTurnStr;


    TextOut(0, LCD_LINE1, rightMsg);
    TextOut(0, LCD_LINE2, leftMsg);
    TextOut(0, LCD_LINE3, tickMsg);
    TextOut(0, LCD_LINE4, compassMsg);
    TextOut(0, LCD_LINE5, rightRotationMsg);
    TextOut(0, LCD_LINE6, leftRotationMsg);
    TextOut(0, LCD_LINE7, timeSinceLastTurnMsg);
   

    if (shouldStop) {
      OnFwd(OUT_AB, 30);
      Off(OUT_AB);
      keepGoing = false;
    } else {
      keepGoing = true;
    }

    if (shouldBeCareful)
    {
      OnFwd(OUT_AB, 25);
    }
    else
    {
      if (shouldTurn)
      {
        if (timeSinceLastTurn < 15000)
        {
          if (leftReading < rightReading) {
            previousTurnTime = CurrentTick();
            OnFwd(OUT_A, 80);
            OnFwd(OUT_B, 0);
          }
          else
          {
            previousTurnTime = CurrentTick();
            OnFwd(OUT_A, 0);
            OnFwd(OUT_B, 80);
          }
        }
        else
        {
          if (leftReading < rightReading) {
            previousTurnTime = CurrentTick();
            OnFwd(OUT_A, 50);
            OnFwd(OUT_B, 25);
          }
          else
          {
            previousTurnTime = CurrentTick();
            OnFwd(OUT_A, 25);
            OnFwd(OUT_B, 50);
          }
        }
      }
      else
      {
        OnFwd(OUT_AB, 75);
      }
    }
  }
}
